---
layout: post
title:  "Learning Common Lisp in 2024"
author: oaguy1
date:   2024-01-11 22:35:13 -0500
categories: programming
tags: programming commonlisp lisp
---

Deciding to invest in a new language is serious business. It takes quite a bit of time to become proficient in any new language, and that's time one could have invested in learning other new skills or simply recovering from a busy work schedule. This mental calculus is somewhat more difficult when it comes to investing in a niche language such as Common Lisp, where it is unlikely I will ever have a professional use for the language.

Some would say that it is frivolous to learn something so out of left field without a chance for some real reward. To them, I would say learning for learning's sake is absolutely a worthwhile investment in its own right. For me, learning something completely different from my everyday work as a Python developer has been incredibly rewarding and intellectually stimulating. I went into this exercise not expecting to get a financial or professional reward. What I have gotten instead is a rekindled obsession with the Lisp family of languages.

I went about learning Common Lisp in the most traditional way possible: with a book. While the prevailing wisdom these days is to start with *Practical Common Lisp* by Peter Seibel, I wanted something contemporary with one of my target Common Lisp implementations, Macintosh Common Lisp 4.2 for Mac OS 9. This meant going back further to one of the first books on the ANSI Common Lisp standard, *ANSI Common Lisp* from 1995 by Paul Graham. This book tends to be overlooked these days for some of its more modern cousins, but I think it was an excellent read, even in 2023 when I read it. The code snippets were clear and correct, and the prose of the book was straightforward and very readable. I honestly devoured the book with some reading sessions stretching over 100 pages. I was lucky and got my copy used for a decent price, but it can sometimes be as expensive as a modern computer science textbook.

For the curious, some of the modern criticism of the book is that its code is somewhat non-idiomatic by today's standards in that it uses short variable names and relies heavily on recursion. It also covers a great many topics in only 286 pages of text (excluding the appendices) and therefore doesn't go into great depth on any one subject. I believe that these are not strict weaknesses. Getting a general overview of as much of the language as possible in a single text is extremely useful. What is more, I've found myself reaching for my copy of the book over my search engine because there is something satisfying about flipping through an index to find the relevant pages. Does this mean I would still offer this book as the essential starting point? Probably not, but I have found it extremely enjoyable and the book helped me with some of my first coding tasks in Common Lisp.

I haven't stopped with *ANSI Common Lisp*, I've also picked up a book specifically about programming macros. Macros, for the uninitiated, are a mechanism for writing code that generates more code. This allows for new programming constructs to be added to the language by the programmer rather than the language implementer. This is one of the most powerful aspects of most Lisp dialects, and therefore I picked up *Let Over Lambda* by Doug Hoyte. Hoyte himself acknowledges that his book builds on *On Lisp*, also by Paul Graham, but copies of *On Lisp* go for around $200 for a physical copy and I really prefer reading on paper. Therefore, *Let Over Lambda* is currently my guide to macros until it goes over my head or I find something better.


Reading about a language is one thing, coding in it is quite another. I started with [Advent of Code 2023](https://adventofcode.com/2023), where I completed the first 6 programming problems before tapping out on day 7. I've made it further in the past using my strongest language, Python, but focused on solving the problems using only Common Lisp and the `uiop` library for file handling. Getting a chance to truly put write some actual Lisp code was enlightening. I did my best to iterate through lists using mapping functions whenever possible and to think of things in a functional way. Still, I did end up dipping my toe into the Common Lisp Object System (CLOS) for some of the later problems, which gave me the foundation I needed for my next project.

After deciding I was done with Advent of Code, I moved on to my first personal project in Common Lisp, a static site generator called [cl-yassg](https://github.com/oaguy1/cl-yassg) or Yet Another Static Site Generator. This took my understanding of working with files to the next level as I was not only inputting an entire directory tree but also parsing the markdown front matter myself because no Common Lisp libraries specifically parse that (yes, YAML parsers exist, but one still needs to separate out the YAML from the markdown). I view cl-yassg as almost feature complete apart from tests.

From here, things have gone slightly off the rails. I've taken a break from Common Lisp to look at other Lisp dialects such as Scheme. I've picked up a copy of the famous *The Structures and Interpretation of Computer Programs* and have started reading through it. I want to eventually implement a minimal Lisp dialect either in Scheme or Common Lisp. I also learned [Fennel](https://fennel-lang.org) in an afternoon along with [LÖVE](https://www.love2d.org) and wrote a [very simple single-player Pong game](https://github.com/oaguy1/pong-fennel). More about the Pong game in another post, but writing a game was an excellent way for me to build something outside my comfort zone while learning a new minimal Lisp.

Where do I plan to go from here? I plan on continuing with cl-yassg until it is complete, and then I need to find another project for Common Lisp. Feel free to ping me on Mastodon with ideas! I also plan on continuing with Fennel and LÖVE, perhaps participating in the annual Lisp Game Jam in May. Now that I feel comfortable in one Lisp dialect, the world of Lisp has opened up, and I plan on exploring as much as I can without losing focus.
